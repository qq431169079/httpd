/* 
**  mod_flashapp.c -- Apache  flashapp module
**  [Autogenerated via ``apxs -n flashapp -g'']
**
**  To play with this  module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_flashapp.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /flashapp in as follows:
**
**    #   httpd.conf
**    LoadModule flashapp_module modules/mod_flashapp.so
**    <Location /flashapp>
**    SetHandler flashapp
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /flashapp and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/flashapp 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The  page from mod_flashapp.c
*/ 


#include "apr_flash.h"

//开关
const char kFlashappName[] = "FlashApp"; //开启主服务
const char kFlashappLogs[] = "FlashApp_Logs";//开启日志
const char kFlashappIpPort[] = "FlashApp_IpPort";//开启 ip port 转化
const char kFlashappPagespeed[] = "FlashApp_Flashsdk";//开启 pagespeed
const char kFlashappUserSetting[] = "FlashApp_UserSetting";//开启用户设置
const char kFlashappOtherProxy[] = "FlashApp_OtherProxy";// 开启后方代理转发
const char kFlashappNoSetProxy[] = "FlashApp_NoSetProxy";// 开启cdn 模式
const char kFlashappDisableServer[] = "FlashApp_DisableServer";// 服务器不可用
const char kFlashappForwardedFor[] = "FlashApp_ForwardedFor";// 打开转发标志
const char kFlashappAllConnect[] = "FlashApp_AllConnect";// 允许connect 连接
const char kFlashappZiproxyAfterSquid[] = "FlashApp_ZiproxyAfterSquid";// squid 后 ziproxy 打开图片url 修改
const char kFlashappUsedForPc[] = "FlashApp_UsedForPc";// 开启pc 访问 flashapp去掉验证  ziproxy去掉其他压缩 保留图片压缩
const char kFlashCheckTrash[] = "FlashApp_CheckTrash";// 开启检测垃圾流量或者显示没用户访问次数



//属性配置
const char kFlashappMode[] = "FlashApp_Mode";// 服务器运行模式
const char kFlashappMemcacheServer[] = "FlashApp_MemcacheServer";//memcache 地址
const char kFlashappMysqlServer[] = "FlashApp_MysqlServer";// mysql 连接串
const char kFlashappLogSumPath[] = "FlashApp_LogSumPath";// 整合后的日志
const char kFlashappLogAllPath[] = "FlashApp_LogAllPath";// 详细日志
const char kFlashappIp2Domain[] = "FlashApp_JsonDomain";// ip doamin 对照 json 文件地址
const char kFlashappLicenceUrl[] = "FlashApp_Licenurl";// 序列号验证url
const char kFlashappDomainMap[] = "FlashApp_DomainMap";// doamin  转换 对照
const char kFlashappCacheMap[] = "FlashApp_CacheMap";// 本地cache 转换 对照
const char kFlashappInsertHead[] = "FlashApp_Head";//  插入http 头内容
const char kFlashappVideoHost[] = "FlashApp_VideoHost";// 视频代理转发服务器地址
const char kFlashappAudioHost[] = "FlashApp_AudioHost";// 音频代理转发服务器地址
const char kFlashappSquidHost[] = "FlashApp_SquidHost";// squid 转发服务器地址
const char kFlashappZiproxyHost[] = "FlashApp_ZiproxyHost";// ziproxy 转发服务器地址
const char kFlashappSquidDomainList[] = "FlashApp_SqDList";// 转发squid 的domain列表
const char kFlashappSquidTypeList[] = "FlashApp_SqTList"; // 转发squid 的 类型
const char kFlashappForbidConnectPortList[] = "FlashApp_ForbidConnectPortList";// 禁止connect的端口
const char kFlashappPagespeedCache[] = "ModFlashsdkFileCachePath";// pagespeed cache 地址 清理缓存用
const char kFlashappForbidAgentList[] = "FlashApp_ForbidAgentList";// 禁用的agent列表
const char kFlashappForbidUrlList[] = "FlashApp_ForbidUrlList";// 禁用的 url 列表 可以domain 可以uri
const char kFlashappMaxVisitPerUser[] = "FlashApp_MaxVisitPerUser";// 1分钟内最大访问次数


//过滤器
const char kFlashappIpPortFilterName[] = "FlashApp_IpPort_In";
const char kFlashappPagespeedFilterName[] = "FlashApp_Pagespeed_Out";
const char kFlashappLogsBeforeFilterName[] = "FlashApp_Logs_Out_Before";
const char kFlashappProcessContentFilterName[] = "FlashApp_Content_In_Out";
const char kFlashappLogsAfterFilterName[] = "FlashApp_Logs_Out_After";
const char kFlashappCommandFilterName[] = "FlashApp_Command_Out";


module AP_MODULE_DECLARE_DATA flashapp_module;


#define whichmode( mode ) \
 ( (( mode ) == AP_MODE_READBYTES) ? "readbytes" : \
   (( mode ) == AP_MODE_GETLINE) ? "getline" : \
   (( mode ) == AP_MODE_EATCRLF) ? "eatcrlf" : \
   (( mode ) == AP_MODE_SPECULATIVE) ? "speculative" : \
   (( mode ) == AP_MODE_EXHAUSTIVE) ? "exhaustive" : \
   (( mode ) == AP_MODE_INIT) ? "init" : "unknown" \
 )

/* 静态文件主函数  */
static apr_status_t flashapp_handler(request_rec *r)
{
	apr_status_t rv=DECLINED;

	flash_conf_t *cf = ap_get_module_config(r->server->module_config,&flashapp_module);

	flash_log_printf(FLASHLOG_MARK,R_LOG, r,"flashapp_handler %s | %s | %s",r->filename,r->hostname,r->handler);

	if (r->handler==NULL || (strcmp(r->handler, "flashapp-handler")!=0)) {
	       return rv;
	}

	if(r->unparsed_uri && (strncasecmp(r->unparsed_uri,"/flashapp-command",17)==0)){
		flashapp_command_run(r,cf);
	}else{
		//处理模块内部本地静态http跳转
		ap_internal_redirect(apr_pstrcat(r->pool, r->filename,
	                       r->args ? "?" : NULL, r->args, NULL), r);
	}
	rv=OK;

	return rv;
}

/* 权限流程判断主函数  */
static apr_status_t flashapp_fixup(request_rec *r)
{
	apr_status_t rv=OK;

	flash_conf_t *cf = ap_get_module_config(r->server->module_config,&flashapp_module);

	flash_conf_req_t *cfr= ap_get_module_config(r->request_config,&flashapp_module);

	if(cf->enable_all){
		//第三方协议
		set_third_party_proxy(r);
		//移动私有协议
		set_xonline_host_proxy(r);

		 // zip 过滤器添加
		 if((cf->spf_head_content!=NULL)||
				 ((cfr->spf_domain_hash!=NULL) && (apr_hash_count(cfr->spf_domain_hash) >0))){
			 ap_add_output_filter("INFLATE",NULL,r,r->connection);
		 }
		 ap_add_output_filter("DEFLATE",NULL,r,r->connection);
		 /////////////////

		//我们自己的地址直接过
		if(cfr->user_info.enable_passthrough ==0 ){
			//不设置代理不验证
			if(cf->enable_nosetproxy==0){
				rv=process_authory(r,cfr,cf);
				if(rv!=APR_SUCCESS){
					rv=HTTP_FORBIDDEN;
				}
			}else{//数字图书馆模式 代理无效
				if(cfr->user_info.enable_used==0){
					rv=HTTP_FORBIDDEN;
				}
			}

			if(cf->enable_usersetting){
				if(rv!=HTTP_FORBIDDEN){
					rv=process_usersetting(r,cfr);
					if(rv!=APR_SUCCESS){
						rv=HTTP_FORBIDDEN;
					}
				}
			}

			//判断是否本地缓存
			if(rv!=HTTP_FORBIDDEN){
				if(detect_flashapp_cache(r,cfr,cf) !=APR_SUCCESS){//本地存在缓存不转发
				//自定义代理协议 代理转发
					if(cf->enable_otherproxy){
						set_xflashapp_proxy(r,cfr,cf);
					}
				}
			}
		}

		//设置错误返回头内容 防止掉转，错误等 导致掉过输出过滤器执行的情况
		if(rv!=APR_SUCCESS){//不加条件 http 头会合并
		 set_command(r,cfr,DECLINED);
		}

		//添加透明代理设置
		if(cf->enable_forwardedfor){
			if(r->proxyreq == PROXYREQ_PROXY){
				apr_table_mergen(r->headers_in, "X-Forwarded-For",
			                         r->connection->remote_ip);
			}
		}

		//connect 代理 允许端口放过
		if(cf->enable_allconnect){
			if(r->method_number == M_CONNECT){
				if(check_connect_port(r,cfr,cf) ==APR_SUCCESS){
					apr_table_mergen(r->headers_in, "X-Flashapp-Connect",
						                 r->parsed_uri.port_str);
				}
			}
		}

		//显示http 头 调试 使用
		flash_log_printf_headers(r,r->headers_in,"head in");
	}

	//清理无效请求http头
	clear_trash_header(r,cfr);

	flash_log_printf(FLASHLOG_MARK,R_LOG, r,"fixup_flash %d ",rv);

    return rv;
    //return OK;//DECLINED
}


//获取之前长度
apr_status_t flash_out_log_before_filter(ap_filter_t *filter, apr_bucket_brigade *bb)
{
	apr_off_t length;

	flash_conf_req_t *cfr = filter->ctx;

	apr_brigade_length (bb, 0, &length);

	if (length > 0)
	    cfr->in_lenadd += length;

//	flash_log_printf(FLASHLOG_MARK,R_LOG, filter->r,"flash_out_log_before_filter ");

	return ap_pass_brigade(filter->next,bb);

}

//获取http  content
apr_status_t flash_in_process_content_filter(ap_filter_t *filter, apr_bucket_brigade *bb,
        ap_input_mode_t eMode,apr_read_type_e eBlock,apr_off_t nBytes)
{
	//flash_log_printf(FLASHLOG_MARK,C_LOG, filter->c,"flash_in_log_filter");

	const char *val;
//	apr_table_t *headers=filter->r->headers_out;
//	val = apr_table_get(headers, "Content-Length");
//	apr_off_t length;


//	flash_log_printf(FLASHLOG_MARK,R_LOG, filter->r,
//			"flash_in_process_content_filter url: %s %"APR_SIZE_T_FMT"   %s",
//			filter->r->unparsed_uri,filter->r->bytes_sent,val);

//	ap_get_brigade(filter->next, bb, eMode, eBlock, nBytes);

//	apr_brigade_length (bb, 0, &length);


//	flash_log_printf(FLASHLOG_MARK,R_LOG, filter->r,
//			"flash_in_process_content_filter ++++++++++++++++ val: %s lent:%d ",val,length);

	//return process_content_from_in(filter,bb,eMode,eBlock,nBytes);
	//return ap_pass_brigade(filter->next,bb);

	return OK;
}

//处理 http content
apr_status_t flash_out_process_content_filter(ap_filter_t *filter, apr_bucket_brigade *bb)
{
	apr_status_t status= DECLINED;

	apr_off_t length;

	request_rec *r = filter->r;

	flash_conf_req_t *cfr = filter->ctx;

	flash_conf_t *cf = ap_get_module_config(filter->r->server->module_config,&flashapp_module);

//	flash_log_printf(FLASHLOG_MARK,R_LOG, filter->r,"flash_out_process_content_filter ");

	//flashapp domain  不操作
	if(cfr->user_info.enable_passthrough == 0){
		// 视频 跳转请求
		//本地缓存的视频，音频不处理
		process_content_video_audio(filter, bb,cf);
		if(cf->spf_head_content!=NULL){
			process_content_inserthead(filter,bb,cf->spf_head_content);
			status = APR_SUCCESS;
		}
	}

	if((cfr->spf_domain_hash!=NULL) && (apr_hash_count(cfr->spf_domain_hash) >0)){
		process_headers_replacehost(filter);
		process_content_replacehost(filter,bb);
		status = APR_SUCCESS;
	}

	if(status != APR_SUCCESS){
		ap_remove_output_filter(filter);
	}

	return ap_pass_brigade(filter->next,bb);
}

//获取之后节省长度
apr_status_t flash_out_log_after_filter(ap_filter_t *filter, apr_bucket_brigade *bb)
{
	flash_conf_req_t *cfr = filter->ctx;

	flash_log_printf_headers((void*)filter->r,filter->r->headers_out,"headout --flash_out_log_after_filter");

	get_headers_length(filter->r,cfr);

	ap_remove_output_filter(filter);

	flash_log_printf(FLASHLOG_MARK,R_LOG, filter->r,"flash_out_log_after_filter");

	return ap_pass_brigade(filter->next,bb);

}

//修改pagespeed  参数 过滤器
apr_status_t flash_out_pagespeed_filter(ap_filter_t *filter, apr_bucket_brigade *bb)
{
	//显示http 头 调试 使用
	//flash_log_printf_headers((void*)filter->r,filter->r->headers_out,"headout --flash_out_pagespeed_filter");

	add_headers_pagespeed(filter);

	flash_log_printf(FLASHLOG_MARK,R_LOG, filter->r,
	          "flash_out_pagespeed_filter %d url: %s  " ,filter->r->status,filter->r->unparsed_uri);

	ap_remove_output_filter(filter);

	return ap_pass_brigade(filter->next,bb);

}

// 向客户端  或其他模块 发送命令 过滤器
apr_status_t flash_out_command_filter(ap_filter_t *filter, apr_bucket_brigade *bb)
{
	flash_conf_req_t *cfr = filter->ctx;

	set_command(filter->r,cfr,APR_SUCCESS);

	//有些数据不能压缩
	flashapp_check_nodeflate(filter->r);
	//显示http 头 调试 使用
	flash_log_printf_headers((void*)filter->r,filter->r->headers_out,"headout --flash_out_command_filter");

	flash_log_printf(FLASHLOG_MARK,R_LOG,filter->r,"flash_out_command_filter");

	ap_remove_output_filter(filter);

	return ap_pass_brigade(filter->next,bb);

}

// 获取 ip port  的过滤器
apr_status_t flash_in_ipport_filter(ap_filter_t *filter, apr_bucket_brigade *bb,
        ap_input_mode_t eMode,apr_read_type_e eBlock,apr_off_t nBytes)
{
	 apr_bucket *b=NULL;
	 apr_bucket *newb=NULL;
	 apr_status_t ret=-1 ,rv=-1;
	 conn_rec *c = filter->c;
	 flash_conf_conn_t *cfc = filter->ctx;
	// apr_off_t length;

	 const char *data;
	 char *bdata;
	 apr_size_t len;

	 if (filter->c->aborted) {
	      apr_bucket *bucket = apr_bucket_eos_create(filter->c->bucket_alloc);
	      APR_BRIGADE_INSERT_TAIL(bb, bucket);
	      return APR_ECONNABORTED;
	 }

	 if(cfc->enable_check){
		 flash_log_printf(FLASHLOG_MARK,C_LOG, c,
	                    "flash_in_ipport_filter: %s [%s-%s] %" APR_OFF_T_FMT " readbytes",
	                    filter->frec->name,
	                    whichmode(eMode),
	                    ((eBlock) == APR_BLOCK_READ) ? "blocking" : "nonblocking",
	                    		nBytes) ;
	 }

	 ret = ap_get_brigade(filter->next, bb, eMode, eBlock, nBytes);

	 if(cfc->enable_check && (ret == APR_SUCCESS) && (!APR_BRIGADE_EMPTY(bb))){

		 for (b = APR_BRIGADE_FIRST(bb); b != APR_BRIGADE_SENTINEL(bb); b = APR_BUCKET_NEXT(b))
		 {
			if (APR_BUCKET_IS_EOS(b)) {
	    	      break;
	    	 }

	    	 if (APR_BUCKET_IS_FLUSH(b)) {
	    	      continue;
	    	 }

	        rv=apr_bucket_read(b, &data, &len, APR_BLOCK_READ);
	        flash_log_printf(FLASHLOG_MARK,C_LOG, c,"read ip port src ......%d : %"APR_SIZE_T_FMT": %s",rv,len,data);
	        if((rv==APR_SUCCESS) && (len>0) && OK==get_ipandport(data,len,&bdata,cfc,c)){
	        	newb=apr_bucket_pool_create(bdata, len,c->pool, bb->bucket_alloc);
	        	APR_BUCKET_INSERT_AFTER(b,newb);
	        	//newb=APR_BUCKET_NEXT(b);
	        	//apr_bucket_delete(b);//真的删除
	        	APR_BUCKET_REMOVE(b);// 只是重环中去掉  只是无效
	        	//b=newb;
	        	//apr_bucket_read(b, &data, &len, APR_BLOCK_READ);
	        	//flash_log_printf(FLASHLOG_MARK,C_LOG, c,"read ......%d : %"APR_SIZE_T_FMT": %s",rv,len,data);
	        	break;
	        }
		 }
		 //keepalive 的时候要有恢复
		 cfc->enable_check=0;
	    }
	 return ret;
}

//输出过滤器 插入接口
static void flash_insert_output_filter(request_rec *r)
{
	flash_conf_t *cf;
	flash_conf_conn_t *cfc;
	flash_conf_req_t *cfr;

	flash_log_printf(FLASHLOG_MARK,R_LOG, r,"flash_insert_output_filter");

	cf = ap_get_module_config(r->server->module_config,&flashapp_module);

	cfc = ap_get_module_config(r->connection->conn_config,&flashapp_module);

	cfr = ap_get_module_config(r->request_config,&flashapp_module);

	 if (cf->enable_all){
		 if(cf->enable_pagespeed){
	        ap_add_output_filter(kFlashappPagespeedFilterName, cfr, r, r->connection);
		 }

		 if(cf->enable_logs){
		    ap_add_output_filter(kFlashappLogsBeforeFilterName, cfr, r, r->connection);
		    ap_add_output_filter(kFlashappLogsAfterFilterName, cfr, r, r->connection);
		 }

		 if(cf->enable_usersetting){
			 ap_add_output_filter(kFlashappCommandFilterName, cfr, r, r->connection);
		 }
		 ap_add_output_filter(kFlashappProcessContentFilterName, cfr, r, r->connection);
	 }
}

//输入过滤器 插入接口
static void flash_insert_input_filter(request_rec *r)
{
	flash_conf_t *cf;
	flash_conf_conn_t *cfc;
	flash_conf_req_t *cfr;

	cf = ap_get_module_config(r->server->module_config,
                                           &flashapp_module);
	cfc = ap_get_module_config(r->connection->conn_config,
	                                       &flashapp_module);
	cfr = ap_get_module_config(r->request_config,&flashapp_module);

	flash_log_printf(FLASHLOG_MARK,R_LOG, r,"flash_insert_input_filter");

	 if (cf->enable_all){
		// if(cf->enable_logs)
		// ap_add_input_filter(kFlashappProcessContentFilterName, cfr, r, r->connection);
	 }
}

//发送日志给日志进程
static apr_status_t flash_log_transaction(request_rec *r)
{
	flash_conf_req_t *cfr = ap_get_module_config(r->request_config,&flashapp_module);

	flash_conf_t *cf;

	cf = (flash_conf_t *) ap_get_module_config(r->connection->base_server->module_config,
	                                                 &flashapp_module);
	if(cf->enable_all){
		if(cf->enable_ipport){
			flash_conf_conn_t *cfc = ap_get_module_config(r->connection->conn_config,&flashapp_module);
			cfc->enable_check = 1;
		}
		if(cf->enable_logs){
			log_collection(r,cfr,cf);
		}
	}

	flash_log_printf(FLASHLOG_MARK,R_LOG, r,"flash_log_transaction");

	return OK;
}

// 创建 con 结构 初始化
static apr_status_t flash_pre_conn(conn_rec *c, void *csd)
{
    flash_conf_t *cf;

    cf = (flash_conf_t *) ap_get_module_config(c->base_server->module_config,
                                                 &flashapp_module);

    if (cf->enable_all){

    	flash_conf_conn_t *cfc = apr_pcalloc(c->pool, sizeof(*cfc));
        cfc->enable_check=1;
        cfc->proxy.pport=0;
        cfc->proxy.paddr.s_addr=0;
        cfc->enable_request=1;

        ap_set_module_config(c->conn_config, &flashapp_module, cfc);

        flash_log_printf(FLASHLOG_MARK,C_LOG,c,"flash_pre_conn");

        if(cf->enable_ipport){
        	ap_add_input_filter(kFlashappIpPortFilterName, cfc, NULL, c);
        }
    }
    return OK;
}

// 传递 con 结构 数据给 req 结构
static apr_status_t flash_post_read_request(request_rec *r)
{
	flash_conf_t *cf;

	apr_hash_index_t *hi=NULL;
	const char *val= NULL;
	char *newhost = NULL;
	char *newrefer= NULL;
	char *pdata=NULL;
	char *pfind=NULL;
	const char *key=NULL;
	const char *value=NULL;
	apr_hash_t *tmp_hash=NULL;
	apr_hash_index_t *tmphi=NULL;
	struct in_addr ipaddr;

	flash_conf_conn_t *cfc = ap_get_module_config(r->connection->conn_config,&flashapp_module);

	cf = (flash_conf_t *) ap_get_module_config(r->server->module_config,
		                                                 &flashapp_module);
	if (cf->enable_all){
		flash_conf_req_t *cfr = ap_get_module_config(r->request_config,&flashapp_module);

		if(cf->enable_serviceinvalid){
			cfr->user_info.enable_used= 0;
		}
		if(cfc->enable_request){
		    cfr->user_info.proxy.pport=cfc->proxy.pport;
		    cfr->user_info.proxy.paddr.s_addr=cfc->proxy.paddr.s_addr;
		}
		cfr->spf_memc = cf->spf_memc;
		cfr->spf_squid = cf->spf_squid;
#ifdef USE_MYSQL
		cfr->spf_mysql = cf->spf_mysql;
#endif
		cfr->spf_mysqllock = cf->spf_mysqllock;
		cfr->user_info.server_mode = cf->server_mode;

		if(r->request_time > 0)
			cfr->s_time = r->request_time;
		else
			cfr->s_time = apr_time_now();

		cfr->spf_json_hash = cf->spf_json_hash;

		//内部命令
		if(r->unparsed_uri && (strncasecmp(r->unparsed_uri,"/flashapp-command",17)==0)){
			r->handler = "flashapp-handler";
			cfr->user_info.enable_passthrough =1;
			return OK;
		}

		///内部跳转 或者定制访问
		//定义不直接通过代理规则
		if(cfr->user_info.enable_passthrough==0){
			val=apr_table_get(r->headers_in,"X-Flashapp-Pass");
			if(val!=NULL){
				cfr->user_info.enable_passthrough =1;
				apr_table_unset(r->headers_in,"X-Flashapp-Pass");
			}
		}

		flash_log_printf(FLASHLOG_MARK,R_LOG, r,
				    			"source request url: %s  ",r->the_request);

	    //带参数的url 访问转换 web proxy
		flashapp_url_proxy(r,cfr,cf);
		//url 缩略
		flashapp_url_forshort(r,cfr,cf);

		if(r->hostname!=NULL && strstr(r->hostname,"flashapp")!=NULL && cfr->user_info.enable_passthrough==0){
			cfr->user_info.enable_passthrough =1;
		}

		if(cfr->user_info.enable_passthrough==0){
			val=apr_table_get(r->headers_in, "User-Agent");
			if(val!=NULL){
				if(strstr(val,"flashapp")){
					cfr->user_info.enable_passthrough =1;
				}
			}
		}
		// agent  和 host  带 flashapp 通过

		flash_log_printf(FLASHLOG_MARK,R_LOG, r,
		       "flash_post_read_request %s:%d",inet_ntoa(cfc->proxy.paddr),cfc->proxy.pport);

		//循环查找domain 列表
		if(r->hostname!=NULL){
		    if(apr_hash_count(cf->spf_domain_hash)>0){
		    	val=apr_table_get(r->headers_in,"Referer");
		    	for (hi = apr_hash_first(r->pool, cf->spf_domain_hash); hi; hi = apr_hash_next(hi)) {
		    		apr_hash_this(hi, (const void**)&key, NULL, (void**)&tmp_hash);
		    		if( (key != NULL) && (tmp_hash != NULL) ){
		    			value=apr_hash_get(tmp_hash,r->hostname,APR_HASH_KEY_STRING);
		    			if(value!=NULL){
		    				cfr->spf_domain_hash = tmp_hash;
		    				if(cf->enable_nosetproxy){
		    					newhost=apr_pstrdup(r->pool,value);
		    					/*
		    					//不是ip 才复制
		    					if(apr_inet_pton(AF_INET,value,&ipaddr)!=1){
		    						newhost=apr_pstrdup(r->pool,value);
		    					}else{
		    						newhost=apr_pstrdup(r->pool,r->hostname);
		    					}
		    					*/

		    					if(val!=NULL){//替换还原 refer
		    						newrefer=apr_pstrdup(r->pool,val);
		    						for(tmphi=apr_hash_first(r->pool,tmp_hash);tmphi;tmphi=apr_hash_next(tmphi)){
		    							apr_hash_this(tmphi, (const void**)&key, NULL, (void**)&value);
		    							if(key!=NULL && value!=NULL){
		    								//不是ip才替换
		    								if(apr_inet_pton(AF_INET,value,&ipaddr)!=1){
		    									pfind=strstr(newrefer,key);
		    									if(pfind!=NULL){
		    										*pfind='\0';
		    										pfind+=strlen(key);
		    										newrefer=apr_pstrcat(r->pool,newrefer,value,pfind, NULL);
		    										break;
		    									}
		    								}
		    							}
		    						}
		    					}
		    				}
		    			}
		    		}
		    	}
		    }
		}

		flash_log_printf(FLASHLOG_MARK,R_LOG, r,
		    			"protocol : %s : %s : %s  ",r->protocol,r->unparsed_uri,r->the_request);

		//no set proxy  user proxy 设置不用代理直接访问
		if(cf->enable_nosetproxy){
			if((r->parsed_uri.hostname ==NULL)&&(newhost!=NULL)){//非代理访问， 并且有新的host 替换 ProxyPreserveHost要 on
				r->proxyreq = PROXYREQ_PROXY;
				r->uri = apr_pstrcat(r->pool,ap_http_scheme(r),"://" ,newhost, r->unparsed_uri, NULL);
				r->filename = apr_pstrcat(r->pool, "proxy:", r->uri, NULL);
				r->handler = "proxy-server";
				//是域名才修改host
				if(apr_inet_pton(AF_INET,newhost,&ipaddr)!=1){
					r->hostname = apr_pstrdup(r->pool,newhost);
					apr_table_set(r->headers_in,"Host",newhost);
				}
				r->unparsed_uri=apr_pstrdup(r->pool,r->uri);
				r->the_request=apr_pstrcat(r->pool, r->method," ",r->unparsed_uri, NULL);
				apr_uri_parse(r->pool, r->unparsed_uri, &r->parsed_uri);

				if(newrefer!=NULL){
					apr_table_set(r->headers_in,"Referer",newrefer);
				}

				val=apr_table_get(r->headers_in,"Referer");
				flash_log_printf(FLASHLOG_MARK,R_LOG, r,
			        	 "no set proxy  filename: %s hostname: %s refer:%s ",r->filename,r->hostname,val);
			}else{// 没有新host 数字图书馆模式 代理无效
				if(cfr->user_info.server_mode==MODE_DLIBRARY){
					if(r->parsed_uri.hostname !=NULL){
					   cfr->user_info.enable_used= 0;
				     }
				}else{//非图书馆模式 代理出发 go
					if((r->parsed_uri.hostname ==NULL)){
						val=apr_table_get(r->headers_in, "X-Forwarded-For");
						if((val==NULL)||((val!=NULL) && (r->connection!=NULL) && (r->connection->remote_ip!=NULL) &&
								(strstr(val,r->connection->remote_ip)==NULL))){
							r->proxyreq = PROXYREQ_PROXY;
							r->uri = apr_pstrcat(r->pool,ap_http_scheme(r),"://" ,r->hostname, r->unparsed_uri, NULL);
							r->filename = apr_pstrcat(r->pool, "proxy:", r->uri, NULL);
							r->handler = "proxy-server";
							r->unparsed_uri=apr_pstrdup(r->pool,r->uri);
							r->the_request=apr_pstrcat(r->pool, r->method," ",r->unparsed_uri, NULL);
							apr_uri_parse(r->pool, r->unparsed_uri, &r->parsed_uri);
							flash_log_printf(FLASHLOG_MARK,R_LOG, r,
									"no set proxy filename: %s hostname: %s",r->filename,r->hostname);
						}else{
							cfr->user_info.enable_used= 0;
						}
					}else{
						//非代理模式 代理不能通过
						cfr->user_info.enable_used= 0;
					}
				}
			}
		}

		//循环查找静态缓存列表
		if(r->hostname!=NULL){
			if(apr_hash_count(cf->spf_cache_hash)>0){
				tmp_hash=apr_hash_get(cf->spf_cache_hash,r->hostname,APR_HASH_KEY_STRING);
				if(tmp_hash!=NULL){
					cfr->spf_cache_hash=tmp_hash;
				}
			}
		}

	}

	return OK;
}

//创建req 结构
static apr_status_t flash_create_request_config(request_rec *r)
{
	flash_conf_req_t *cfr = apr_pcalloc(r->pool, sizeof(*cfr));
	cfr->user_info.proxy.pport= 0;
	cfr->user_info.proxy.paddr.s_addr= 0;
	cfr->in_len = 0;
	cfr->in_lenadd =0;
	cfr->out_len = 0;
	cfr->s_time = 0;
	cfr->e_time = 0;
	cfr->user_info.enable_settoken = 0;
	cfr->user_info.enable_used = 1;
	cfr->user_info.check_result = 0;
	cfr->user_info.enable_passthrough =0;
	cfr->user_info.access_urlproxy =0;
	cfr->user_info.enable_pagespeed =1;
	cfr->user_info.sdk_stepmode = 0;
	cfr->user_info.spf_appid= NULL;
	cfr->user_info.spf_pkgid= NULL;
	cfr->user_info.spf_devid= NULL;
	cfr->user_info.spf_tagent= NULL;
	cfr->user_info.spf_nettype = NULL;
	cfr->user_info.spf_imgype = NULL;
	cfr->user_info.spf_codetoken = NULL;
	cfr->user_info.spf_platformtype = NULL;

	cfr->user_info.spf_timestamp = NULL;
	cfr->user_info.spf_devname = NULL;
	cfr->user_info.spf_osversion = NULL;
	cfr->user_info.spf_mccnc = NULL;
	cfr->user_info.spf_channel = NULL;

	cfr->user_info.spf_urlshort = NULL;
	cfr->user_info.spf_urlshortparam = NULL;

	cfr->user_info.server_mode = MODE_USER;

	cfr->user_info.auth_mode = MODE_LANXUN;//MODE_NORMAL

	cfr->user_info.image_quality= IQ_MID;

	cfr->spf_memc = NULL;
	cfr->spf_squid = NULL;
#ifdef USE_MYSQL
	cfr->spf_mysql = NULL;
#endif
	cfr->spf_mysqllock = NULL;
	cfr->spf_domain_hash = NULL;
	cfr->spf_cache_hash = NULL;

	cfr->image_c.all_len = 0;
	cfr->image_c.now_len = 0;
	cfr->image_c.type_image = NO_CHECK;
	cfr->image_c.spf_all_cache = NULL;

//	flash_log_printf(FLASHLOG_MARK,R_LOG, r,"flash_create_request_config ");

	ap_set_module_config(r->request_config, &flashapp_module, cfr);

	return OK;
}

//监控状态 2.22 无
static apr_status_t flash_monitor(apr_pool_t *p, server_rec *s)
{
	flash_log_printf(FLASHLOG_MARK,P_LOG, p,
							   "flash_monitor: =========================");
	return OK;
}

//初始化每个线程参数 // memcache mysql
static void flash_init_child(apr_pool_t *p, server_rec *s)
{
	apr_status_t ret=0;
	flash_conf_t *cf = (flash_conf_t *) ap_get_module_config(s->module_config,&flashapp_module);
	if(cf->enable_all){
		if(cf->spf_squid_proxy!=NULL){
			ret=init_hashcluster(p,cf->spf_squid_proxy,&(cf->spf_squid));
			if(ret!=APR_SUCCESS){
				ap_log_error(APLOG_MARK, APLOG_ERR,0,s,"open squid error ! host %s ret %d",
						cf->spf_squid_proxy,ret);
			}
		}

		if(cf->enable_usersetting){
			if(cf->spf_ip2domain_path){
				init_json_domain(p,cf,s);
			}

			if(cf->spf_memcache_slist!=NULL){
				ret=init_memcache(p,cf->spf_memcache_slist,&(cf->spf_memc));
				if(ret!=APR_SUCCESS){
					ap_log_error(APLOG_MARK, APLOG_ERR,0,s,"open memcached error ! host %s ret %d",
							cf->spf_memcache_slist,ret);
				}
			}

#ifdef USE_MYSQL
			if(cf->server_mode == MODE_SDK){
				if(cf->spf_mysql_slist!=NULL){
					ret=init_mysql(p,cf->spf_mysql_slist,&(cf->spf_mysql));
					if(ret!=APR_SUCCESS){
						ap_log_error(APLOG_MARK, APLOG_ERR,ret,s,"open mysql error ! host %s",cf->spf_mysql_slist);
					}
					apr_thread_mutex_create(&cf->spf_mysqllock, APR_THREAD_MUTEX_DEFAULT, p);
				}
			}
			//释放 mysql
			apr_pool_cleanup_register(p, cf, child_proc_close, child_proc_close);
#endif
		}
	}
	flash_log_printf(FLASHLOG_MARK,S_LOG, s,"flash_init_child");
}

//开启 summary 日志进程
static apr_status_t flash_open_logs(apr_pool_t *pconf, apr_pool_t *plog,
        apr_pool_t *ptemp, server_rec *s)
{
	void *data = NULL;
	const char *userdata_key = "flash_open_logs";

	flash_conf_t *cf = (flash_conf_t *) ap_get_module_config(s->module_config,
					                                                 &flashapp_module);
	if(cf->enable_all){
		if(cf->enable_logs){
			flash_log_printf(FLASHLOG_MARK,S_LOG, s,"flash_open_logs");

			//启动 要执行两次， 判断第二次 才开启 log 日志进程
			apr_pool_userdata_get(&data, userdata_key, s->process->pool);
			if (data == NULL) {
				apr_pool_userdata_set((const void *)1, userdata_key,
		                    apr_pool_cleanup_null, s->process->pool);
				return OK;
			}
			start_log_proc(plog,s,cf);
		}
	}

	return OK;
}

//license 验证
static apr_status_t flash_post_config(apr_pool_t *pconf, apr_pool_t *plog,
                             apr_pool_t *ptemp, server_rec *s)
{
	flash_log_printf(FLASHLOG_MARK,S_LOG, s,"flash_post_config");

	flash_conf_t *cf = (flash_conf_t *) ap_get_module_config(s->module_config,
						                                 &flashapp_module);
#ifdef HAS_CHECK_LICENCE
	check_server_license(ptemp,cf,s);
#endif
	return OK;
}

static void flash_add_default_squid_type(apr_pool_t *p,apr_array_header_t *squid_typearry, server_rec *s)
{
	flash_squid_type_t *pitem=NULL;
	pitem=apr_array_push(squid_typearry);
	pitem->spf_type=apr_pstrdup(p,"image/gif");
	pitem=apr_array_push(squid_typearry);
	pitem->spf_type=apr_pstrdup(p,"image/jpeg");
	pitem=apr_array_push(squid_typearry);
	pitem->spf_type=apr_pstrdup(p,"image/png");
}

static void flash_add_default_forbid_connect_port(apr_pool_t *p,apr_array_header_t *forbcon_port, server_rec *s)
{
	flash_connect_port_t *pitem=NULL;
	pitem=apr_array_push(forbcon_port);
	pitem->icport=25;
	pitem=apr_array_push(forbcon_port);
	pitem->icport=110;
	pitem=apr_array_push(forbcon_port);
	pitem->icport=143;
}

//创建全局结构
static void *flash_create_sconfig(apr_pool_t *p, server_rec *s)
{
    flash_conf_t *cf = apr_pcalloc(p, sizeof(*cf));

    cf->enable_all=1;

    cf->enable_ipport=0;

    cf->enable_pagespeed = 0;

    cf->enable_logs=0;

    cf->enable_usersetting = 0;

    cf->enable_otherproxy = 0;

    cf->enable_nosetproxy = 0;

    cf->enable_serviceinvalid = 0;

    cf->enable_forwardedfor = 0;

    cf->enable_allconnect = 0;

    cf->enable_ziproxyaftersquid = 0;

    cf->enable_usedforpc = 0;

    cf->enable_trashcheck =0;

    cf->max_visitperuser =100;

    cf->server_mode = MODE_USER;

    cf->spf_logsum_path = NULL;

    cf->spf_logall_path = NULL;

    cf->spf_ip2domain_path =NULL;

    cf->spf_memcache_slist=NULL;

    cf->log_sumfd = NULL;

    cf->log_allfd = NULL;

    cf->spf_memc = NULL;

    cf->spf_squid = NULL;
#ifdef USE_MYSQL
    cf->spf_mysql = NULL;
#endif

    cf->spf_mysqllock = NULL;

    cf->spf_domain_hash = NULL;

    cf->spf_cache_hash = NULL;

    cf->spf_json_hash = NULL;

    cf->spf_mysql_slist = NULL;

    cf->spf_lice_url = NULL;

    cf->spf_head_content = NULL;

    cf->spf_audio_proxy = NULL;

    cf->spf_video_proxy = NULL;

    cf->spf_mysql_slist =NULL;

    cf->spf_ziproxy_proxy =NULL;

    cf->spf_pagespeed_cache =NULL;

    cf->spf_squid_domainarry =NULL;

    cf->spf_forbid_agentarry =NULL;

    cf->spf_forbid_urlarry =NULL;

    cf->spf_squid_typearry =NULL;

    cf->spf_forbid_connect_port =NULL;

    cf->spf_domain_hash = apr_hash_make(p);

    cf->spf_cache_hash = apr_hash_make(p);

    cf->spf_json_hash = apr_hash_make(p);

    cf->spf_squid_domainarry =apr_array_make(p,1,sizeof(flash_squid_host_t));

    cf->spf_squid_typearry =apr_array_make(p,1,sizeof(flash_squid_type_t));

    cf->spf_forbid_connect_port =apr_array_make(p,1,sizeof(flash_connect_port_t));

    cf->spf_forbid_agentarry =apr_array_make(p,1,sizeof(flash_forbid_agent_t));

    cf->spf_forbid_urlarry =apr_array_make(p,1,sizeof(flash_forbid_url_t));

    flash_add_default_squid_type(p,cf->spf_squid_typearry,s);

    flash_add_default_forbid_connect_port(p,cf->spf_forbid_connect_port,s);

    return cf;
}

static void flashapp_register_hooks(apr_pool_t *p)
{

    ap_hook_insert_filter(flash_insert_output_filter, NULL, NULL, APR_HOOK_FIRST);

    ap_hook_insert_filter(flash_insert_input_filter, NULL, NULL, APR_HOOK_FIRST);

    //获取 ip和端口的 过滤器
    ap_register_input_filter(kFlashappIpPortFilterName, flash_in_ipport_filter, NULL,
            		AP_FTYPE_CONNECTION);

    //获取压缩之前的大小 解压之前的大小 要在deflate 解压之前获取
    ap_register_output_filter(kFlashappLogsBeforeFilterName, flash_out_log_before_filter, NULL,
              (ap_filter_type)(AP_FTYPE_RESOURCE-2));//AP_FTYPE_CONTENT_SET-1 AP_FTYPE_RESOURCE-2

    //pagespeed  控制参数添加
    ap_register_output_filter(
    		kFlashappPagespeedFilterName, flash_out_pagespeed_filter, NULL,
    						(ap_filter_type)(AP_FTYPE_RESOURCE));

    //向客户端 和 其他模块 传送控制命令
    ap_register_output_filter(
            kFlashappCommandFilterName, flash_out_command_filter, NULL,
            						(ap_filter_type)(AP_FTYPE_RESOURCE));

    //处理 替换 http 内容 和http 头内容 moblize 在 pagespeed 过滤器之后
    ap_register_output_filter(
    		kFlashappProcessContentFilterName, flash_out_process_content_filter, NULL,
                (ap_filter_type)(AP_FTYPE_RESOURCE+3));

    //获取 http 内容
//    ap_register_input_filter(kFlashappProcessContentFilterName, flash_in_process_content_filter, NULL,
//    		(ap_filter_type)(AP_FTYPE_CONTENT_SET));

    //log 记录优化长度
    ap_register_output_filter(kFlashappLogsAfterFilterName, flash_out_log_after_filter, NULL,
    		(ap_filter_type)(AP_FTYPE_PROTOCOL));

    //license 验证
    ap_hook_post_config(flash_post_config, NULL, NULL, APR_HOOK_MIDDLE);

    //启动log 进程
    ap_hook_open_logs(flash_open_logs, NULL, NULL, APR_HOOK_REALLY_LAST);

    //子进程初始化
    ap_hook_child_init(flash_init_child, NULL, NULL, APR_HOOK_MIDDLE);

    //初始化用户参数 过滤器参数  一个连接一次
    ap_hook_pre_connection(flash_pre_conn, NULL, NULL, APR_HOOK_FIRST);

    //c  参数传入 r
    ap_hook_post_read_request(flash_post_read_request, NULL, NULL,APR_HOOK_MIDDLE);

    //初始化 req 结构
    ap_hook_create_request(flash_create_request_config, NULL, NULL,APR_HOOK_MIDDLE);

    //权限判断 有时候执行两遍
    ap_hook_fixups(flashapp_fixup,NULL,NULL,APR_HOOK_MIDDLE);

    //静态文件映射
    ap_hook_handler(flashapp_handler,NULL,NULL,APR_HOOK_MIDDLE);

    //最后执行记录log 输出
    ap_hook_log_transaction(flash_log_transaction,NULL,NULL,APR_HOOK_MIDDLE);

    //监控
    //ap_hook_monitor(flash_monitor, NULL, NULL, APR_HOOK_MIDDLE);

}


static const char *flash_enable_all(cmd_parms *cmd, void *dummy, int arg)
{
    flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
    cf->enable_all = arg;
    return NULL;
}

static const char *flash_enable_ipport(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config,
	                                       &flashapp_module);

	cf->enable_ipport = arg;
	return NULL;
}



static const char *flash_enable_pagespeed(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_pagespeed = arg;
    return NULL;
}


static const char *flash_enable_logs(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_logs = arg;
    return NULL;
}

static const char *flash_enable_usersetting(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_usersetting = arg;
    return NULL;
}


static const char *flash_enable_otherproxy(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_otherproxy = arg;

    return NULL;
}

static const char *flash_enable_nosetproxy(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_nosetproxy = arg;

    return NULL;
}

static const char *flash_enable_invalid(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_serviceinvalid = arg;
    return NULL;
}

static const char *flash_enable_forwardedfor(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_forwardedfor = arg;
    return NULL;
}


static const char *flash_enable_allconnect(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_allconnect = arg;
    return NULL;
}

static const char *flash_enable_ziproxyaftersquid(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_ziproxyaftersquid = arg;
    return NULL;
}


static const char *flash_enable_usedforpc(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_usedforpc = arg;
    return NULL;
}

static const char *flash_enable_trashcheck(cmd_parms *cmd, void *dummy, int arg)
{
	flash_conf_t *cf =
    (flash_conf_t *) ap_get_module_config(cmd->server->module_config,
                                           &flashapp_module);
	cf->enable_trashcheck = arg;
    return NULL;
}

static const char * flash_set_mode(cmd_parms *cmd, void *dummy,const char *smode)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);

	if(smode!=NULL){
		if(strncasecmp(smode, "flashsdk", 8)==0){
			cf->server_mode= MODE_SDK;
			cf->enable_logs =1;
			cf->enable_pagespeed =1;
			cf->enable_usersetting =1;
			cf->enable_otherproxy =1;
			cf->enable_forwardedfor =1;
			cf->enable_allconnect = 1;
			cf->enable_ziproxyaftersquid = 1;

		}else if(strncasecmp(smode, "flashuser", 9)==0){
			cf->server_mode= MODE_USER;
			cf->enable_logs =1;
			cf->enable_pagespeed =1;
			cf->enable_usersetting =1;
			cf->enable_ipport = 1;
			cf->enable_otherproxy =1;
			cf->enable_forwardedfor =1;
			cf->enable_allconnect = 1;
			cf->enable_ziproxyaftersquid = 1;

		}else if(strncasecmp(smode, "flashdlibrary", 12)==0){
			cf->server_mode= MODE_DLIBRARY;
			cf->enable_logs =1;
			cf->enable_otherproxy =1;
			cf->enable_pagespeed =1;
			cf->enable_nosetproxy =1;
			cf->enable_forwardedfor =1;
			cf->enable_allconnect = 1;
		}else if(strncasecmp(smode, "flashnoproxy",12)==0){
			cf->server_mode= MODE_NOPROXY;
			cf->enable_logs =1;
			cf->enable_otherproxy =1;
			cf->enable_pagespeed =1;
			cf->enable_nosetproxy =1;
			cf->enable_forwardedfor =1;
			cf->enable_allconnect =1;
			cf->enable_usedforpc = 1;
			cf->enable_ziproxyaftersquid = 1;
		}
	}
	return NULL;
}

static const char *flash_set_memcacheserver(cmd_parms *cmd, void *dummy,const char *list)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_memcache_slist = list;
	return NULL;
}

static const char *flash_set_mysqlserver(cmd_parms *cmd, void *dummy,const char *params)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_mysql_slist = params;
	return NULL;
}

static const char *flash_set_logallpath(cmd_parms *cmd, void *dummy,const char *path)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_logall_path = path;
	return NULL;
}

static const char *flash_set_ip2domain(cmd_parms *cmd, void *dummy,const char *path)
{
	flash_conf_t *cf =
			(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_ip2domain_path = path;
	return NULL;
}


static const char *flash_set_logsumpath(cmd_parms *cmd, void *dummy,const char *path)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_logsum_path = path;
	return NULL;
}

static const char *flash_set_liceurl(cmd_parms *cmd, void *dummy,const char *url)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_lice_url = url;
	return NULL;
}

static const char *flash_set_head(cmd_parms *cmd, void *dummy,const char *content)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_head_content = content;
	return NULL;
}

static const char *flash_set_videohost(cmd_parms *cmd, void *dummy,const char *vhost)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_video_proxy=vhost;
	return NULL;
}

static const char *flash_set_audiohost(cmd_parms *cmd, void *dummy,const char *ahost)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_audio_proxy=ahost;
	return NULL;
}

static const char *flash_set_squidhost(cmd_parms *cmd, void *dummy,const char *ahost)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_squid_proxy=ahost;
	return NULL;
}

static const char *flash_set_ziproxyhost(cmd_parms *cmd, void *dummy,const char *ahost)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_ziproxy_proxy=ahost;
	return NULL;
}

static const char *flash_set_squiddomainlist(cmd_parms *cmd, void *dummy,const char *list)
{
	char *host_list=NULL;
	char *split=NULL;
	char *tok=NULL;
	flash_squid_host_t *pitem=NULL;
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	if(list!=NULL){
		apr_array_clear(cf->spf_squid_domainarry);
		host_list = apr_pstrdup(cmd->pool, list);
		if(host_list!=NULL){
			split = apr_strtok(host_list, ",", &tok);
			while (split) {
					pitem=apr_array_push(cf->spf_squid_domainarry);
					pitem->spf_host=apr_pstrdup(cmd->pool,split);
		        	split = apr_strtok(NULL,",", &tok);
			}
		}
	}
	return NULL;
}

static const char *flash_set_squidtypelist(cmd_parms *cmd, void *dummy,const char *list)
{
	char *type_list=NULL;
	char *split=NULL;
	char *tok=NULL;
	flash_squid_type_t *pitem=NULL;
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	if(list!=NULL){
		apr_array_clear(cf->spf_squid_typearry);
		type_list = apr_pstrdup(cmd->pool, list);
		if(type_list!=NULL){
			split = apr_strtok(type_list, ",", &tok);
			while (split) {
					pitem=apr_array_push(cf->spf_squid_typearry);
					pitem->spf_type=apr_pstrdup(cmd->pool,split);
		        	split = apr_strtok(NULL,",", &tok);
			}
		}
	}
	return NULL;
}

static const char *flash_set_forbidconnectportlist(cmd_parms *cmd, void *dummy,const char *list)
{
	char *port_list=NULL;
	char *split=NULL;
	char *tok=NULL;
	flash_connect_port_t *pitem=NULL;
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	if(list!=NULL){
		apr_array_clear(cf->spf_forbid_connect_port);
		port_list = apr_pstrdup(cmd->pool, list);
		if(port_list!=NULL){
			split = apr_strtok(port_list, ",", &tok);
			while (split) {
					pitem=apr_array_push(cf->spf_forbid_connect_port);
					pitem->icport=atoi(split);
		        	split = apr_strtok(NULL,",", &tok);
			}
		}
	}
	return NULL;
}

static const char *flash_set_forbidagentlist(cmd_parms *cmd, void *dummy,const char *list)
{
	char *agent_list=NULL;
	char *split=NULL;
	char *tok=NULL;
	flash_forbid_agent_t *pitem=NULL;
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	if(list!=NULL){
		apr_array_clear(cf->spf_forbid_agentarry);
		agent_list = apr_pstrdup(cmd->pool, list);
		if(agent_list!=NULL){
			split = apr_strtok(agent_list, ",", &tok);
			while (split) {
					pitem=apr_array_push(cf->spf_forbid_agentarry);
					pitem->spf_agent = apr_pstrdup(cmd->pool,split);
		        	split = apr_strtok(NULL,",", &tok);
			}
		}
	}
	return NULL;
}

static const char *flash_set_forbidurllist(cmd_parms *cmd, void *dummy,const char *list)
{
	char *url_list=NULL;
	char *split=NULL;
	char *tok=NULL;
	flash_forbid_url_t *pitem=NULL;
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	if(list!=NULL){
		apr_array_clear(cf->spf_forbid_urlarry);
		url_list = apr_pstrdup(cmd->pool, list);
		if(url_list!=NULL){
			split = apr_strtok(url_list, ",", &tok);
			while (split) {
					pitem=apr_array_push(cf->spf_forbid_urlarry);
					pitem->spf_url=apr_pstrdup(cmd->pool,split);
		        	split = apr_strtok(NULL,",", &tok);
			}
		}
	}
	return NULL;
}

static const char *flash_get_pagespeedcache(cmd_parms *cmd, void *dummy,const char *path)
{
	flash_conf_t *cf =
		(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);
	cf->spf_pagespeed_cache=path;
	return NULL;
}

static const char *flash_set_maxvisitperuser(cmd_parms *cmd, void *dummy,const char *max)
{
	flash_conf_t *cf =
		(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);

	cf->max_visitperuser=atoi(max);
	if(cf->max_visitperuser<=0){
		cf->max_visitperuser=100;
	}
	return NULL;
}

static const char *flash_add_domainmap(cmd_parms *cmd, void *dummy, const char *main,
		const char *src,const char *dst)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);

	apr_hash_t * tmp_hash=NULL;
	char *mkey=NULL;
	char *ckey=NULL;
	char *cvalue=NULL;

	if((main!=NULL)&&(src!=NULL)&&(dst!=NULL)){
		mkey=apr_pstrdup(cmd->pool,main);
		ckey=apr_pstrdup(cmd->pool,dst);
		cvalue=apr_pstrdup(cmd->pool,src);

		if(cf->spf_domain_hash){
			tmp_hash=apr_hash_get(cf->spf_domain_hash,mkey,APR_HASH_KEY_STRING);
			if(tmp_hash==NULL){
				tmp_hash=apr_hash_make(cmd->pool);
				apr_hash_set(cf->spf_domain_hash,mkey, APR_HASH_KEY_STRING, tmp_hash);
			}
			apr_hash_set(tmp_hash,ckey, APR_HASH_KEY_STRING, cvalue);
		}
	}

	return NULL;
}

static const char *flash_add_cachemap(cmd_parms *cmd, void *dummy, const char *host,
		const char *uri,const char *path)
{
	flash_conf_t *cf =
	(flash_conf_t *) ap_get_module_config(cmd->server->module_config, &flashapp_module);

	apr_hash_t * tmp_hash=NULL;
	char *mkey=NULL;
	char *ckey=NULL;
	char *cvalue=NULL;

	if((host!=NULL)&&(uri!=NULL)&&(path!=NULL)){
		mkey=apr_pstrdup(cmd->pool,host);
		ckey=apr_pstrdup(cmd->pool,uri);
		cvalue=apr_pstrdup(cmd->pool,path);

		if(cf->spf_cache_hash){
			tmp_hash=apr_hash_get(cf->spf_cache_hash,mkey,APR_HASH_KEY_STRING);
			if(tmp_hash==NULL){
				tmp_hash=apr_hash_make(cmd->pool);
				apr_hash_set(cf->spf_cache_hash,mkey, APR_HASH_KEY_STRING, tmp_hash);
			}
			apr_hash_set(tmp_hash,ckey, APR_HASH_KEY_STRING, cvalue);
		}
	}

	return NULL;
}

static const command_rec flash_cmds[] = {
    AP_INIT_FLAG(kFlashappName, flash_enable_all, NULL,
                 RSRC_CONF, "Enable  FlashApp"),
    AP_INIT_FLAG(kFlashappIpPort, flash_enable_ipport, NULL,
                 RSRC_CONF, "Enable Get User Ip and Port"),
    AP_INIT_FLAG(kFlashappPagespeed, flash_enable_pagespeed, NULL,
                 RSRC_CONF, "Enable Flashsdk"),
    AP_INIT_FLAG(kFlashappLogs, flash_enable_logs, NULL,
                 RSRC_CONF, "Enable Logs"),
    AP_INIT_FLAG(kFlashappUserSetting, flash_enable_usersetting, NULL,
                 RSRC_CONF, "Enable UserSettings"),
    AP_INIT_FLAG(kFlashappOtherProxy, flash_enable_otherproxy, NULL,
                 RSRC_CONF, "Enable ogher proxy for back"),
    AP_INIT_FLAG(kFlashappNoSetProxy, flash_enable_nosetproxy, NULL,
                 RSRC_CONF, "cleint not used set proxy need for dns or host set to domain"),
    AP_INIT_FLAG(kFlashappDisableServer, flash_enable_invalid, NULL,
                 RSRC_CONF, "set the proxy disable"),
    AP_INIT_FLAG(kFlashappForwardedFor, flash_enable_forwardedfor, NULL,
                 RSRC_CONF, "set the forwarded_for enable"),
    AP_INIT_FLAG(kFlashappAllConnect, flash_enable_allconnect, NULL,
                 RSRC_CONF, "set the allow all port connect"),
    AP_INIT_FLAG(kFlashappZiproxyAfterSquid, flash_enable_ziproxyaftersquid, NULL,
                 RSRC_CONF, "set the ziproxy after squid"),
    AP_INIT_FLAG(kFlashappUsedForPc, flash_enable_usedforpc, NULL,
                 RSRC_CONF, "set the used for  pc"),
    AP_INIT_FLAG(kFlashCheckTrash, flash_enable_trashcheck, NULL,
                 RSRC_CONF, "set the used for  pc"),

    AP_INIT_TAKE1(kFlashappMode,flash_set_mode, NULL,
                 RSRC_CONF,"Set Server mode:flashsdk,flashuser,flashdlibrary,flashnoproxy"),

    AP_INIT_TAKE1(kFlashappMemcacheServer,flash_set_memcacheserver, NULL,
    			RSRC_CONF,"Set Memcache Server List"),

    AP_INIT_TAKE1(kFlashappMysqlServer,flash_set_mysqlserver, NULL,
    			RSRC_CONF,"Set Mysql Server params"),

    AP_INIT_TAKE1(kFlashappLogSumPath,flash_set_logsumpath, NULL,
    			RSRC_CONF,"Set Flash sum logs path"),

    AP_INIT_TAKE1(kFlashappLogAllPath,flash_set_logallpath, NULL,
    			RSRC_CONF,"Set Flash all logs path"),

    AP_INIT_TAKE1(kFlashappIp2Domain,flash_set_ip2domain, NULL,
    			RSRC_CONF,"Set Flash ip domain file path"),

    AP_INIT_TAKE1(kFlashappLicenceUrl,flash_set_liceurl, NULL,
    			RSRC_CONF,"Set check licence url "),

    AP_INIT_TAKE1(kFlashappInsertHead,flash_set_head, NULL,
    			RSRC_CONF,"Set insert head content "),

    AP_INIT_TAKE1(kFlashappVideoHost,flash_set_videohost, NULL,
    			RSRC_CONF,"Set video proxy  host "),

    AP_INIT_TAKE1(kFlashappAudioHost,flash_set_audiohost, NULL,
    			RSRC_CONF,"Set audio proxy host "),

    AP_INIT_TAKE1(kFlashappSquidHost,flash_set_squidhost, NULL,
    			RSRC_CONF,"Set squid proxy host "),

    AP_INIT_TAKE1(kFlashappZiproxyHost,flash_set_ziproxyhost, NULL,
    			RSRC_CONF,"Set ziproxy proxy host "),

    AP_INIT_TAKE1(kFlashappSquidDomainList,flash_set_squiddomainlist, NULL,
    			RSRC_CONF,"Set squid domain list "),

    AP_INIT_TAKE1(kFlashappSquidTypeList,flash_set_squidtypelist, NULL,
    			RSRC_CONF,"Set squid type list "),

    AP_INIT_TAKE1(kFlashappForbidConnectPortList,flash_set_forbidconnectportlist, NULL,
    			RSRC_CONF,"Set forbid connect port list "),

    AP_INIT_TAKE1(kFlashappForbidAgentList,flash_set_forbidagentlist, NULL,
    			RSRC_CONF,"Set forbid agent list "),

    AP_INIT_TAKE1(kFlashappForbidUrlList,flash_set_forbidurllist, NULL,
    			RSRC_CONF,"Set forbid url list "),

    AP_INIT_TAKE1(kFlashappPagespeedCache,flash_get_pagespeedcache, NULL,
    			RSRC_CONF,"get pagespeed cache path"),

    AP_INIT_TAKE1(kFlashappMaxVisitPerUser,flash_set_maxvisitperuser, NULL,
    		    RSRC_CONF,"one min max user max visit"),

    AP_INIT_TAKE3(kFlashappDomainMap,flash_add_domainmap,NULL,
    			RSRC_CONF, "add map domain"),

    AP_INIT_TAKE3(kFlashappCacheMap,flash_add_cachemap,NULL,
    			RSRC_CONF, "add static map  cache"),


    { NULL }
};

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA flashapp_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    flash_create_sconfig,  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    flash_cmds,             /* table of config file commands       */
    flashapp_register_hooks  /* register hooks                      */
};

